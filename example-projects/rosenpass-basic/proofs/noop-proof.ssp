Proof NoonKemProof {
  const kem_sk_len: Integer;
  const kem_pk_len: Integer;
  const kem_ct_len: Integer;
  const kem_shk_len: Integer;
  const kem_rand_len: Integer;

  const encaps: fn (Bits(n_rand), Bits(pk_len)) -> (Bits(shk_len), Bits(ct_len));
  const keygen: fn Bits(sk_len) -> Bits(pk_len);

  instance kem_real: KemAssumption {
    params {
      is_ideal: false,

      kem_sk_len: kem_sk_len,
      kem_pk_len: kem_pk_len,
      kem_ct_len: kem_ct_len,
      kem_shk_len: kem_shk_len,
      kem_rand_len: kem_rand_len,

      encaps: encaps,
      keygen: keygen,
    }
  }

  instance kem_ideal: KemAssumption {
    params {
      is_ideal: true,

      kem_sk_len: kem_sk_len,
      kem_pk_len: kem_pk_len,
      kem_ct_len: kem_ct_len,
      kem_shk_len: kem_shk_len,
      kem_rand_len: kem_rand_len,

      encaps: encaps,
      keygen: keygen,
    }
  }

  instance proto_real: MysteryProtocol {
    params {
      is_ideal: false,

      kem_sk_len: kem_sk_len,
      kem_pk_len: kem_pk_len,
      kem_ct_len: kem_ct_len,
      kem_shk_len: kem_shk_len,
      kem_rand_len: kem_rand_len,

      encaps: encaps,
      keygen: keygen,
    }
  }

  instance proto_ideal: MysteryProtocol {
    params {
      is_ideal: true,

      kem_sk_len: kem_sk_len,
      kem_pk_len: kem_pk_len,
      kem_ct_len: kem_ct_len,
      kem_shk_len: kem_shk_len,
      kem_rand_len: kem_rand_len,

      encaps: encaps,
      keygen: keygen,
    }
  }

  assumptions {
    Kem: kem_real ~ kem_ideal
  }

  gamehops {
    reduction proto_real proto_ideal {
      assumption Kem

      map kem_real proto_real {
        kem: kem
        asym_keys: asym_keys
        kem_rand: kem_rand
        output: kem_output
      }

      map kem_ideal proto_ideal {
        kem: kem
        asym_keys: asym_keys
        kem_rand: kem_rand
        output: kem_output
      }
    }
  }
}
