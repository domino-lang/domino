
(define-fun state-equality
    ((state-H5 (Array Int (Maybe (Tuple11 Int Bool Int Bits_n (Maybe Bool) (Maybe Bits_n)
                                          (Maybe Bits_n) (Maybe Bits_n) (Maybe Bits_n)
                                          (Maybe (Tuple5 Int Int Bits_n Bits_n Bits_n)) Int))))
     (state-H6 (Array Int (Maybe (Tuple11 Int Bool Int Int (Maybe Bool) (Maybe Bits_n)
                                          (Maybe Bits_n) (Maybe Bits_n) (Maybe Bits_n)
                                          (Maybe (Tuple5 Int Int Bits_n Bits_n Bits_n)) Int))))
     (prf-H6 (Array Int (Maybe Bits_n)))
     (hon-H6 (Array Int (Maybe Bool))))
  Bool
  (forall ((ctr Int))
          (and (= (is-mk-none (select state-H5 ctr))
                  (is-mk-none (select state-H6 ctr)))
               (let ((state (select state-H6 ctr)))
                 (=> (not (is-mk-none state))
                     (let  ((U    (el11-1  (maybe-get state)))
                            (u    (el11-2  (maybe-get state)))
                            (V    (el11-3  (maybe-get state)))
                            (kid  (el11-4  (maybe-get state)))
                            (acc  (el11-5  (maybe-get state)))
                            (k    (el11-6  (maybe-get state)))
                            (ni   (el11-7  (maybe-get state)))
                            (nr   (el11-8  (maybe-get state)))
                            (kmac (el11-9  (maybe-get state)))
                            (sid  (el11-10 (maybe-get state)))
                            (mess (el11-11 (maybe-get state))))
                       (let ((ltk (select prf-H6 kid))
                             (hon (select hon-H6 kid)))
                         (and (= k (as mk-none (Maybe Bits_n)))
                              (not (= ltk (as mk-none (Maybe Bits_n))))
                              (not (= hon (as mk-none (Maybe Bool))))
                              (= (select state-H5 ctr)
                                 (mk-some (mk-tuple11 U u V (maybe-get ltk) acc (as mk-none (Maybe Bits_n))
                                                      ni nr kmac sid mess)))))))))))


(define-state-relation relation-no-overwriting
    ((left  <GameState_H5_<$<!n!>$>>)
     (right  <GameState_H6_<$<!n!>$>>))
  (forall ((i Int))
          (=> (> i right.PRF.kid_)
              (and (is-mk-none (select right.PRF.LTK i))
                   (is-mk-none (select right.PRF.H i))))))


(define-state-relation relation-ltk-and-h-set-equally
    ((left  <GameState_H5_<$<!n!>$>>)
     (right  <GameState_H6_<$<!n!>$>>))
  (forall ((i Int))
          (= (is-mk-none (select right.PRF.LTK i))
             (is-mk-none (select right.PRF.H i)))))

;; ni and nr are not none when accepted!

(define-fun nonces-are-not-none
    ((state (Array Int (Maybe (Tuple11 Int Bool Int Int (Maybe Bool) (Maybe Bits_n)
                                       (Maybe Bits_n) (Maybe Bits_n) (Maybe Bits_n)
                                       (Maybe (Tuple5 Int Int Bits_n Bits_n Bits_n)) Int))))
     (hon (Array Int (Maybe Bool))))
  Bool
  (let ((none (as mk-none (Maybe (Tuple11 Int Bool Int Int (Maybe Bool) (Maybe Bits_n)
                                          (Maybe Bits_n) (Maybe Bits_n) (Maybe Bits_n)
                                          (Maybe (Tuple5 Int Int Bits_n Bits_n Bits_n)) Int)))))
    (forall ((ctr Int))
            (let ((state (select state ctr)))
              (=> (not (= state none))
                  (let  ((U    (el11-1  (maybe-get state)))
                         (u    (el11-2  (maybe-get state)))
                         (V    (el11-3  (maybe-get state)))
                         (ltk  (el11-4  (maybe-get state)))
                         (acc  (el11-5  (maybe-get state)))
                         (k    (el11-6  (maybe-get state)))
                         (ni   (el11-7  (maybe-get state)))
                         (nr   (el11-8  (maybe-get state)))
                         (kmac (el11-9  (maybe-get state)))
                         (sid  (el11-10 (maybe-get state)))
                         (mess (el11-11 (maybe-get state))))
                    (=> (and (= acc (mk-some true))
                             (= (select hon ltk) (mk-some true)))
                        (and (not (is-mk-none ni))
                             (not (is-mk-none nr))))))))))


(define-fun stuff-not-initialized-early
    ((state (Array Int (Maybe (Tuple11 Int Bool Int Int (Maybe Bool) (Maybe Bits_n)
                                       (Maybe Bits_n) (Maybe Bits_n) (Maybe Bits_n)
                                       (Maybe (Tuple5 Int Int Bits_n Bits_n Bits_n)) Int)))))
  Bool
  (let ((none (as mk-none (Maybe (Tuple11 Int Bool Int Int (Maybe Bool) (Maybe Bits_n)
                                          (Maybe Bits_n) (Maybe Bits_n) (Maybe Bits_n)
                                          (Maybe (Tuple5 Int Int Bits_n Bits_n Bits_n)) Int)))))
    (forall ((ctr Int))
            (let ((state (select state ctr)))
              (=> (not (= state none))
                  (let  ((U    (el11-1  (maybe-get state)))
                         (u    (el11-2  (maybe-get state)))
                         (V    (el11-3  (maybe-get state)))
                         (ltk  (el11-4  (maybe-get state)))
                         (acc  (el11-5  (maybe-get state)))
                         (k    (el11-6  (maybe-get state)))
                         (ni   (el11-7  (maybe-get state)))
                         (nr   (el11-8  (maybe-get state)))
                         (kmac (el11-9  (maybe-get state)))
                         (sid  (el11-10 (maybe-get state)))
                         (mess (el11-11 (maybe-get state))))
                    (and (ite u
                              (ite (> mess 0)
                                   (and (not (= kmac (as mk-none (Maybe Bits_n))))
                                        (not (= ni (as mk-none (Maybe Bits_n))))
                                        (not (= nr (as mk-none (Maybe Bits_n)))))
                                   (= ni nr kmac (as mk-none (Maybe Bits_n))))
                              (ite (= mess 0)
                                   (= ni nr kmac (as mk-none (Maybe Bits_n)))
                                   (ite (= mess 1)
                                        (and (not (= ni (as mk-none (Maybe Bits_n))))
                                             (= nr kmac (as mk-none (Maybe Bits_n))))
                                        (and (not (= kmac (as mk-none (Maybe Bits_n))))
                                             (not (= ni (as mk-none (Maybe Bits_n))))
                                             (not (= nr (as mk-none (Maybe Bits_n)))))))))))))))


(define-state-relation relation-trivial-equalities
    ((left  <GameState_H5_<$<!n!>$>>)
     (right  <GameState_H6_<$<!n!>$>>))
  (and (= left.Nonces.Nonces right.Nonces.Nonces)
       (= left.KX.Fresh     right.KX.Fresh)
       (= left.KX.First     right.KX.First)
       (= left.KX.Second    right.KX.Second)
       (= left.KX.RevTested right.KX.RevTested)
       (= left.KX.ctr_      right.KX.ctr_)
       (= left.KX.LTK       right.PRF.LTK)
       (= left.KX.H         right.PRF.H)
       (= left.KX.kid_      right.PRF.kid_)))


(define-state-relation invariant
    ((left <GameState_H5_<$<!n!>$>>)
     (right <GameState_H6_<$<!n!>$>>))
  (and (relation-trivial-equalities left right)
       (relation-no-overwriting left right)
       (relation-ltk-and-h-set-equally left right)
       (stuff-not-initialized-early right.KX.State)
       (state-equality left.KX.State right.KX.State right.PRF.LTK right.PRF.H)))
