\section{SSBee}
\subsection{Pseudo-code}
We already saw an example of SSBee pseudocode in Section~\ref{sec:ssp} and now discuss the features and limitations of SSBee pseudocode more comprehensively.
In terms of basic operations, SSBee pseudocode supports assignment to state variables and temporary variables (whose value will be forgotten after the oracle call), creating and parsing tuples, sampling uniformly from a set, and evaluation of unspecified function as well as oracle calls. State variables can be individual values or tables. Pseudo-code can contain a special $\mathbf{assert}\mathsf{ cond}$ command which aborts the oracle run if condition $\mathsf{cond}$ is violated. Moreover, SSBee supports if-then-else branching as well as for loops.

\paragraph{Type system.}
SSBee operates on typed symbols, e.g., symbols can be integers (Int),
Booleans (Bool), bitstrings of length n (Bits(n)), tuples of values,
tables etc.. Moreover, the user can specify additional types. For 
every type $\mathsf{type}$, the operation $\mathsf{Maybe}\;\mathsf{type}$
creates a larger type which contains $\mathsf{type}$, but a value
might also be $\mathsf{none}$.

Maybe types are particularly useful for tables. Concretely, at each position, a table might either have a value or be unassigned. Thus, when accessing a table at a position, it is unclear whether it is of the type of values that the table typically contains or of type $\mathsf{none}$. Therefore, a value $v\leftarrow T[i]$ is considered to be of $\mathsf{Maybe}\;\mathsf{type}$, and to turn $v$ into $\mathsf{type}$, we ... which we can only apply if we are guaranteed that $v\leftarrow T[i]$ is not 
equal to $\mathsf{none}$.

\paragraph{Limitations of SSBee pseudocode.}
Sampling from arbitrary distributions needs to be modeled by sampling uniformly from
a set and applying a function to the result. Since SSBee pseudocode is symbolic, it
does not have a concept of length for bitstrings. As a result, in the IND-CPA encryption example, the oracle accepts messages of a \emph{fixed} length $n$ rather
than to allow for different message lengths and checking that the two provided messages are of equal length.

\subsection{Proofs}
As briefly hinted in Section~\ref{X}, SSBee supports \emph{reduction proofs}
as well as \emph{code equivalence proofs}. The user specifies the sequence
of games...example? \emph{reduction proofs}


{\color{blue}Chris: Maybe, the following should move somewhere else, because
it is not SSBee-specific?}
\paragraph{Code equivalence proofs.} Code equivalence proofs between a left
game and a right game proceed by \emph{induction} over the number of oracle calls. We first define a state relation and show that it holds on the pair of initial
states. Next, we need to show the following two statements:
\begin{itemize}
\item[(1)] If the state relation holds before an oracle call, then it holds after an oracle call.
\item[(2)] If the state relation holds before an oracle call, then the two games either both abort or both return the same output.
\end{itemize}
For item (2) (and sometimes also for item (1)), it is necessary to relate the
\emph{randomness} of two games


\paragraph{for-loops.}



\paragraph{Hybrid proofs.} Hybrid proofs are sequences of reduction steps
and code-equivalence proofs, so the SSBee merely ties those together.

