; invariant
; Notation: Left: no mapping, Right: mapping
;      TIKL: T in input  (top)    key package left
;      TIKR: T in input  (top)    key package right
;      TOKL: T in output (bottom) key package left
;      TOKR: T in output (bottom) key package right
;      MIR : input- mapping table (right)
;      MOR : output-mapping table (right)
;
; Left-Right Invariant:
; (LRIa) TIKL[h] != bot iff MIR[h] != bot 
; (LRIb) MIR [h]  = h' != bot => TIKL[h] = TIKR[h']
; (LROa) TOKL[h] != bot iff MOR[h] != bot 
; (LROb) MOR [h]  = h' != bot => TOKL[h] = TOKR[h']
;
; Right-Right Invariant:
; (RI) (exists h s.t. MIR[h] = h') iff TIKR[h'] != bot
; (RO) (exists h s.t. MOR[h] = h') iff TOKR[h'] != bot
; 
; Post-condition:
; called on same inputs, then output is the same and if output was not abort, then same state
;


; define invariant on s-left,s-right
(define-fun inv                                        ; function name 
           ((s-left  CompositionState-no_mapping_game) ; function input 
            (s-right CompositionState-mapping_game))
            Bool                                       ; function behaviour           
            ( 
            (TIKL (Array Int               Bits_n))   ;      TIKL: T in output (bottom) key package left
            (TIKR (Array Int               Bits_n))   ;      TIKR: T in output (bottom) key package right
            (TOKL (Array Tuple__Int_Bits_* Bits_n))   ;      TOKL: T in output (bottom) key package left
            (TOKR (Array Tuple__Int_Bits_* Bits_n))   ;      TOKR: T in output (bottom) key package right
            (MIR  (Array Int Int))                    ;      MIR : input- mapping table (right)
            (MOR  (Array Tuple__Int_Bits_* 
                         Tuple__Int_Bits_*))          ;      MOR : output- mapping table (right)
  
                ; assignment of tables
                    let ((TIKL (state-no_mapping_game-key_pkg_top-T
                            (composition-state-no_mapping_game-key_pkg_top 
                             s-left)))
                         (TIKR (state-mapping_game-key_pkg_top_map-T 
                            (composition-state-mapping_game-key_pkg_top_map
                             s-right)))
                         (TOKL (state-no_mapping_game-key_pkg_bottom-T
                            (composition-state-no_mapping_game-key_pkg_bottom 
                            s-left)))
                         (TOKR (state-mapping_game-key_pkg_bottom_mapping-T
                            (composition-state-mapping_game-key_pkg_bottom_mapping
                            s-right)))
                         (MIR  (state-mapping_game-map_pkg-Input_Map
                            (composition-state-mapping_game-map_pkg
                             s-right)))
                         (MOR  (state-mapping_game-map_pkg-Output_Map  
                            (composition-state-mapping_game-map_pkg
                             s-right)))
                )
                (ite
                (and            ;;;;; (= bot bot) below is always dummy code to be replaced
                ; (LRIa)  TIKL[h] = bot => MIR[h]  = bot 
                    (forall ((h Int)) (=> (= (TIKL h) bot) (= (MIR h) bot))) ; removed
                ; (LRIa') MIR[h]  = bot => TIKL[h]    
                    (forall ((h Int)) (=>  (= (MIR h) bot) (= (TIKR h) bot))) ; removed 
                ; (LRIb)  MIR [h] = hh  => TIKL[h] = TIKR[h'] or hh=bot         
                    (forall ((h Int) (hh Int)) 
                                     (=>  (= (MIR h) hh) (or (= (TIKL h) (TIKR hh)) ; removed, undefined (= (MIR h) hh)
                                                            (= hh bot)))) ; removed, bot still has wrong type (= hh bot)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;    removed the following because sort Tuple__Int_Bits_* not yet defined
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

                ; (LROa)  TOKL[h] = bot => MOR[h]  = bot
                    (forall ((h Tuple__Int_Bits_*)) 
                                      (=> (= (TOKL h) bot) (= (MIR h) bot)))
                ; (LROa') MOR[h]  = bot => TOKL[h]  = bot 
                    (forall ((h Tuple__Int_Bits_*)) 
                                      (=> (= (MOR h) bot) (= (TOKR h) bot)))            
                ; (LROb)  MOR [h] = hh  => TOKL[h] = TOKR[h'] or hh=bot         
                    (forall ((h Tuple__Int_Bits_*) (hh Tuple__Int_Bits_*)) 
                                     (=> (= (MOR h) hh) (or (= (TOKL h) (TIKR hh))
                                                            (= hh bot))))
                ; (RI)  (exists h s.t. MIR[h] = h') => TIKR[h'] != bot
                    (forall ((hh Int)(h Int)) 
                                     (=> 
                                     (= bot bot) ; removed undefined (= (MIR h) hh)
                                     (or (not (=  (TIKR hh) bot))
                                              (= bot bot)))) ; bot still needs to be typed: (= hh bot)
                ; (RI') TIKR[h'] != bot => (exists h s.t. MIR[h] = h')
                    (forall ((hh Int)) 
                                     (=> 
                                     (not (=  (TIKR hh) bot))
                                     (
                                     exists ((h Int))
                                     (= bot bot) ; MIR still undefined (= (MIR h) hh)
                                     )))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;    removed the following because type Tuple__Int_Bits_* not yet defined
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


                ; (RO)  (exists h s.t. MOR[h] = h') => TOKR[h'] != bot
                    (forall ((hh Tuple__Int_Bits_*)) 
                                     (=> 
                                     (
                                     (exists (h Tuple__Int_Bits_*))
                                     (= (MOR h) hh)
                                     )
                                     (or (not (=  (TOKR hh) bot)
                                              (= hh bot)))))
                ; (RO') TOKR[h'] != bot => (exists h s.t. MOR[h] = h')
                    (forall ((hh Tuple__Int_Bits_*)) 
                                     (=> 
                                     (or (not (=  (TOKR hh) bot)
                                              (= hh bot))))
                                     (
                                     (exists (h Tuple__Int_Bits_*))
                                     (= (MOR h) hh)
                                     ))
            )
            true
            false
            )


;;;;;;;;;; SET oracle
; existential quantification
(assert (and (exists 
               ((s-left-old  CompositionState-no_mapping_game)
               (s-right-old CompositionState-mapping_game)   
               (s-left-new  CompositionState-no_mapping_game)
               (s-right-new CompositionState-mapping_game)
               (h Int)
               (k Bits_n))
(and
; pre-condtion
    (= (inv s-left-old s-right-old))     ; undefined stuff 

(not (or
; post-condtion
      (= (inv s-left-new s-right-new))  ; undefined stuff 
      (= y-left-new y-right-new )  ; undefined stuff 
))

; assignment after execution
      (= left-new     oracle-key_pkg_top-Set s-left-old (h k))) ; left function on left state
      (= s-left-new   return-key_pkg_top-Set-state left-new)
      (= y-left-new   return-key_pkg_top-Set-value left-new)
      (= right-new    oracle-key_pkg_top_map-Set s-right-old (h k)) ; left function on left state     
      (= s-right-new  return-key_pkg_top_map-Set-state right-new)
      (= y-right-new  return-key_pkg_top_map-Set-value right-new)
)
))

; manual concat
;(assert (forall ((n Int)) (= (__sample-rand-real n) (__sample-rand-mono-prf-game n))))

(check-sat)
(get-model)
