; invariant
; Notation: Left: no mapping, Right: mapping
;      TIKL: T in input  (top)    key package left
;      TIKR: T in input  (top)    key package right
;      TOKL: T in output (bottom) key package left
;      TOKR: T in output (bottom) key package right
;      MIR : input- mapping table (right)
;      MOR : output-mapping table (right)
;
; Left-Right Invariant:
; (LRIa) TIKL[h] != bot iff MIR[h] != bot 
; (LRIb) MIR [h]  = h' != bot => TIKL[h] = TIKR[h']
; (LROa) TOKL[h] != bot iff MOR[h] != bot 
; (LROb) MOR [h]  = h' != bot => TOKL[h] = TOKR[h']
;
; Right-Right Invariant:
; (RI) (exists h s.t. MIR[h] = h') iff TIKR[h'] != bot
; (RO) (exists h s.t. MOR[h] = h') iff TOKR[h'] != bot
; 
; Post-condition:
; called on same inputs, then output is the same and if output was not abort, then same state
;


; define invariant on s-left,s-right
(define-fun inv                                        ; function name 
           ((s-left  CompositionState-no_mapping_game) ; function input 
            (s-right CompositionState-mapping_game))
            Bool                                       ; function behaviour           
             (
        let  (
            (bot (as mk-none (Maybe Bits_n)))
            (botint (as mk-none (Maybe Int))) 
            (botstuff (as mk-none (Maybe (Tuple2 Int Bits_*))))
             )

             ( 
;            (TIKL (Array Int               Bits_n))   ;      TIKL: T in output (bottom) key package left
;            (TIKR (Array Int               Bits_n))   ;      TIKR: T in output (bottom) key package right
;            (TOKL (Array (Tuple2 Int Bits_*) Bits_n)) ;      TOKL: T in output (bottom) key package left
;            (TOKR (Array (Tuple2 Int Bits_*) Bits_n)) ;      TOKR: T in output (bottom) key package right
;            (MIR  (Array Int Int))                    ;      MIR : input- mapping table (right)
;            (MOR  (Array (Tuple2 Int Bits_*) 
;                         (Tuple2 Int Bits_*)))        ;      MOR : output- mapping table (right)
  
                ; assignment of tables
                    let ((TIKL (state-no_mapping_game-key_pkg_top-T
                            (composition-state-no_mapping_game-key_pkg_top 
                             s-left)))
                         (TIKR (state-mapping_game-key_pkg_top_map-T 
                            (composition-state-mapping_game-key_pkg_top_map
                             s-right)))
                         (TOKL (state-no_mapping_game-key_pkg_bottom-T
                            (composition-state-no_mapping_game-key_pkg_bottom 
                            s-left)))
                         (TOKR (state-mapping_game-key_pkg_bottom_mapping-T
                            (composition-state-mapping_game-key_pkg_bottom_mapping
                            s-right)))
                         (MIR  (state-mapping_game-map_pkg-Input_Map
                            (composition-state-mapping_game-map_pkg
                             s-right)))
                         (MOR  (state-mapping_game-map_pkg-Output_Map  
                            (composition-state-mapping_game-map_pkg
                             s-right)))
                )
                (ite
                (and           
                ; (LRIa)  TIKL[h] = bot => MIR[h]  = bot 
                    (forall ((h Int)) (=> (= (TIKL h) bot) (= (MIR h) botint))) 
                ; (LRIa') MIR[h]  = bot => TIKL[h]    
                    (forall ((h Int)) (=>  (= (MIR h) botint) (= (TIKR h) bot))) 
                ; (LRIb)  MIR [h] = (hh Int) => TIKL[h] = TIKR[hh]         
                    (forall ((h Int) (hh  Int)) 
                                     (
                                     =>  (= (MIR h) (mk-some hh))  (= (TIKL h) (TIKR hh)) 
                                     )
                    ) 
                ; (LROa)  TOKL[h] = bot => MOR[h]  = bot
                    (forall ((h (Tuple2 Int Bits_*))) 
                                      (=> (= (TOKL h) bot) (= (MOR h) botstuff)))
                ; (LROa') MOR[h]  = bot => TOKL[h]  = bot 
                    (forall ((h (Tuple2 Int Bits_*))) 
                                      (=> (= (MOR h) botstuff) (= (TOKR h) bot)))            
                ; (LROb)  MOR [h] = hh  => TOKL[h] = TOKR[hh]         
                    (forall ((h (Tuple2 Int Bits_*)) (hh (Tuple2 Int Bits_*)))
                                     (=>
                                     (= (MOR h) (mk-some hh))                                     
                                     (= (TOKL h) (TOKR hh))))
                ; (RI)  (exists h s.t. MIR[h] = h') => TIKR[h'] != bot
                    (forall ((hh Int)(h Int)) 
                                     (=> 
                                     (= (MIR h) (mk-some hh)) ; if MIR[h] = hh: Int (that is, not bot) 
                                     (not (=  (TIKR hh) bot) ; then TIKR[hh] neq bot
                                              )))
                ; (RI') TIKR[h'] != bot => (exists h s.t. MIR[h] = h')
                    (forall ((hh Int)) 
                                     (=> 
                                     (not (=  (TIKR hh) bot))
                                     (
                                     exists ((h Int))
                                     (= (MIR h) (mk-some hh)) 
                                     )))
                ; (RO)  (exists h s.t. MOR[h] = hh) => exists (hhh Int) TOKR[hh] = hhh
                    (forall ((hh (Tuple2 Int Bits_*))) 
                                     (=> 
                                     (
                                     exists ((h (Tuple2 Int Bits_*)))
                                     (= (MOR h) (mk-some hh))
                                     )
                                     (
                                     exists ((hhh Bits_n))
                                     (= (TOKR hh) (mk-some hhh))
                                     )
                                     ))
                ; (RO') TOKR[hh] = (k Bits_n)) => (exists h s.t. MOR[h] = hh)
                    (forall ((hh (Tuple2 Int Bits_*))(k Bits_n)) 
                                     (=> 
                                     (=  (TOKR hh) (mk-some k)
                                     )
                                     (exists ((h (Tuple2 Int Bits_*)))
                                     (= (MOR h) (mk-some hh))
                                     )
                                     )
                    )
            )
            true
            false
            ))))


;;;;;;;;;; SET oracle
; existential quantification
(assert (and (exists 
               (
               (s-left-old CompositionState-no_mapping_game)
               (s-right-old CompositionState-mapping_game)   
               (h Int)
               (k Bits_n)
               )
(and
; pre-condtion
    (= true (inv s-left-old s-right-old))     

; assignment after execution
      (let ((left-new     (oracle-key_pkg_top-Set s-left-old h k))) ; left function on left state
      (let ((s-left-new   (return-key_pkg_top-Set-state left-new)))
      (let ((y-left-new   (return-key_pkg_top-Set-value left-new)))
      (let ((right-new    (oracle-key_pkg_top_map-Set s-right-old h k))) ; right function on right state     
      (let ((s-right-new  (return-key_pkg_top_map-Set-state right-new)))
      (let ((y-right-new  (return-key_pkg_top_map-Set-value right-new)))

; post-condtion
   (not (or
      (= true (inv s-left-new s-right-new)) 
      (= y-left-new y-right-new ) 
))
)
)))
      ))))))


;;;;;;;;;; EVAL oracle
; existential quantification
(assert (and (exists 
               (
               (s-left-old CompositionState-no_mapping_game)
               (s-right-old CompositionState-mapping_game)   
               ; These two lines change from oracle to oracle
               (h Int)
               (m Bits_*)
               )
(and
; pre-condtion
    (= true (inv s-left-old s-right-old))     

; assignment after execution
      ;The following 6 lines changes from oracle to oracle:
      (let ((left-new     (oracle-prf-Eval s-left-old h m))) ; left function on left state
      (let ((s-left-new   (return-prf-Eval-state left-new)))
      (let ((y-left-new   (return-prf-Eval-value left-new)))
      (let ((right-new    (oracle-map_pkg-Eval s-right-old h m))) ; right function on right state     
      (let ((s-right-new  (return-map_pkg-Eval-state right-new)))
      (let ((y-right-new  (return-map_pkg-Eval-value right-new)))


; post-condtion
   (not (or
      (= true (inv s-left-new s-right-new))  ; undefined stuff 
      (= y-left-new y-right-new )  ; undefined stuff 
))
)
)))
      ))))))

;;;;;;;;;; GET oracle
; existential quantification
(assert (and (exists 
               (
               (s-left-old CompositionState-no_mapping_game)
               (s-right-old CompositionState-mapping_game)   
               ; These two lines change from oracle to oracle
               (h (Tuple2 Int Bits_*))
               )
(and
; pre-condtion
    (= true (inv s-left-old s-right-old))     

; assignment after execution
      ;The following 6 lines changes from oracle to oracle:
      (let ((left-new     (oracle-key_pkg_bottom-Get s-left-old h))) ; left function on left state
      (let ((s-left-new   (return-key_pkg_bottom-Get-state left-new)))
      (let ((y-left-new   (return-key_pkg_bottom-Get-value left-new)))
      (let ((right-new    (oracle-map_pkg-Get s-right-old h))) ; right function on right state     
      (let ((s-right-new  (return-map_pkg-Get-state right-new)))
      (let ((y-right-new  (return-map_pkg-Get-value right-new)))

; post-condtion
   (not (or
      (= true (inv s-left-new s-right-new))  ; undefined stuff 
      (= y-left-new y-right-new )  ; undefined stuff 
))
)
)))
      ))))))


(check-sat)
;(get-model)
