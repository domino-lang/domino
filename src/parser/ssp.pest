WHITESPACE = _{ " " | "\r" | "\n" | "\t" }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }


kw_package = _{ "package" }
kw_params = _{ "params" }
kw_state = _{ "state" }
kw_import = _{ "import" }
kw_oracles = _{ "oracles" }
kw_oracle = _{ "oracle" }
kw_parse = _{ "parse" }
kw_types = _{ "types" }

kw_composition = _{ "composition" }
kw_const = _{ "const" }
kw_instance = _{ "instance" }
kw_compose = _{ "compose" }

kw_return = _{ "return" }
kw_assert = _{ "assert" }
kw_abort = _{ "abort" }
kw_invoke = _{ "invoke" }

kw_true  = _{ "true" }
kw_false = _{ "false" }
kw_emptyset = _{ "emptyset" }

composition = { kw_composition ~ identifier ~ "{" ~ composition_spec_list ~ "}" }
composition_spec_list = { const_decl* ~ instance_decl* ~ compose_decl? }

const_decl = { kw_const ~ identifier ~ ":" ~ tipe ~ ";" }

instance_decl = { kw_instance ~ identifier ~ "=" ~ identifier ~ "{" ~ instance_assign_list? ~ "}"}
instance_assign_list = { instance_assign ~ ( instance_assign )* }
instance_assign = _{ params_def | types_def }

compose_decl = { kw_compose ~ "{" ~ compose_assign_body_list? ~ "}" }
compose_assign_body_list = _{ compose_assign_body ~ ( "," ~ compose_assign_body)* ~ ","? }
compose_assign_body = { identifier ~ ":" ~ "{" ~ compose_assign_list? ~ "}" }
compose_assign_list = _{ compose_assign ~ ( "," ~ compose_assign)* ~ ","? }
compose_assign = { identifier ~ ":" ~ identifier }

package = { kw_package ~ identifier ~ "{" ~ package_spec_list ~ "}" }

package_spec_list = { package_spec* }

package_spec = _{
    types | params | state | import_oracles | oracle_def
}

// these are for package files
params = { kw_params ~ ("{" ~ decl_list ~ "}" | "{" ~ "}") }
decl_list = { decl_spec ~ ( "," ~ decl_spec )* ~ ","? }
decl_spec = { identifier ~ ":" ~ tipe  }

types = { kw_types ~ ("{" ~ types_list ~ "}" | "{" ~ "}") }
types_list = { type_userdefined ~ ( "," ~ type_userdefined )* ~ ","? }

// these are for composition files in instance blocks
params_def = { kw_params ~ ("{" ~ params_def_list ~ "}" | "{" ~ "}") }
params_def_list = { params_def_spec ~ ( "," ~ params_def_spec )* ~ ","? }
params_def_spec = { identifier ~ ":" ~ ( literal | identifier )  }

types_def = { kw_types ~ ("{" ~ types_def_list ~ "}" | "{" ~ "}") }
types_def_list = { types_def_spec ~ ( "," ~ types_def_spec )* ~ ","? }
types_def_spec = { type_userdefined ~ ":" ~ tipe }

countspec = { identifier | num | "*" }

tipe = _{ type_integer | type_bool | type_string | type_bits | type_maybe | type_fn | type_tuple | type_table | type_list | type_empty | type_userdefined }
    type_integer = { "Integer" }
    type_bool = { "Bool" }
    type_string = { "String" }
    type_bits = { "Bits(" ~ countspec ~ ")" }
    type_maybe = { "Maybe(" ~ tipe ~ ")" }
    type_fn = { "fn" ~ fn_arglist ~ "->" ~ tipe }
        fn_arglist = { fn_arg_spec ~ ( "," ~ fn_arg_spec )* }
        fn_arg_spec = { ( identifier ~ ":" )? ~ tipe }
    type_tuple = { "(" ~ tipe ~ ( "," ~ tipe )* ~ ")"}
    type_empty = { "()" }
    type_list = { "List(" ~ tipe ~ ")"}
    type_table = { "Table(" ~ tipe ~ "," ~ tipe ~ ")" }
    type_userdefined = @{ ( ASCII_ALPHA | "_" ) ~ ( ASCII_ALPHA | ASCII_DIGIT | "_" )* }

state = { kw_state ~ "{" ~ decl_list? ~ "}"  }

fn_maybe_arglist = { fn_arglist? }

import_oracles = {kw_import ~ kw_oracles ~ ( "{" ~ ( oracle_sig ~ ("," ~ oracle_sig)* ~ ","? )? ~ "}" )  }
oracle_sig = { identifier ~ "(" ~ fn_maybe_arglist ~ ")" ~ ("->" ~ tipe)? }

oracle_def = { kw_oracle ~ oracle_sig ~ "{" ~ code ~ "}" }


identifier = @{ ( ASCII_ALPHA | "_" ) ~ ( ASCII_ALPHA | ASCII_DIGIT | "_" )* }
num = { ASCII_DIGIT+ }

literal_boolean = { kw_true | kw_false }
literal_integer = { num }
literal_emptyset = { kw_emptyset ~ "as" ~ tipe }

literal = _{ literal_boolean | literal_emptyset | literal_integer }


code = { (stmt )* }
stmt = _{ table_sample | table_assign | sample | parse | invocation | assign | return_stmt | assert | abort | ite}

ite = {"if" ~ expression ~ "{" ~ code ~ "}" ~ ( "else" ~ "{" ~ code ~ "}" )? }

sample = { identifier ~ "<-$" ~ tipe ~ ";" }
assign = { identifier ~ "<-" ~ expression ~ ";" }
invocation = { identifier ~ ( "[" ~ table_index ~ "]" )? ~ "<-" ~ kw_invoke ~ fn_call ~ ";" }
parse = { parse_tuple ~ "<-" ~  kw_parse ~ expression ~ ";" }
    parse_tuple = { "(" ~ identifier ~ ("," ~ identifier )* ~ ")" }
table_sample = { identifier ~ "[" ~ expression ~ "]" ~ "<-$" ~ tipe ~ ";" }
table_assign = { identifier ~ "[" ~ expression ~ "]" ~ "<-" ~ expression ~ ";" }
return_stmt = { kw_return ~ expression? ~ ";" }
assert = { kw_assert ~ expression ~ ";" }
abort = { kw_abort ~ ";" }

table_index = { expression }

expression = _{ expr_list | expr_set | expr_none | expr_some | expr_unwrap | expr_add | expr_sub | expr_mul | expr_div | expr_or | expr_and | expr_xor | expr_not | expr_tuple | expr_equals | expr_not_equals | expr_newtable | fn_call | table_access | literal | identifier }

expr_equals     = { "("  ~ expression ~ ("==" ~ expression)* ~ ")" }
expr_not_equals = { "("  ~ expression ~ ("!=" ~ expression)* ~ ")" }

expr_add     = { "("  ~ expression ~ "+" ~ expression ~ ")" }
expr_sub     = { "("  ~ expression ~ "-" ~ expression ~ ")" }
expr_mul     = { "("  ~ expression ~ "*" ~ expression ~ ")" }
expr_div     = { "("  ~ expression ~ "/" ~ expression ~ ")" }

expr_and     = { "("  ~ expression ~ ("and" ~ expression)* ~ ")" }
expr_or      = { "("  ~ expression ~ ("or"  ~ expression)* ~ ")" }
expr_xor     = { "("  ~ expression ~ ("xor" ~ expression)* ~ ")" }
expr_not     = { "not" ~ expression }

expr_newtable = { "new" ~ "Table" ~ "(" ~ tipe ~ "," ~ tipe ~ ")" }

fn_call =  { identifier ~ "(" ~ fn_call_arglist? ~ ")" }
fn_call_arglist = { expression ~ ( "," ~ expression)* }

expr_none = { "None" ~ "as" ~ tipe }
expr_some = { "Some" ~ "(" ~ expression ~ ")" }
expr_unwrap = { "Unwrap" ~ "(" ~ expression ~ ")" }

table_access = { identifier ~ "[" ~ expression ~                       "]" }
expr_tuple   = {              "(" ~ expression ~ ("," ~ expression)* ~ ")" }
// TODO: in the future we might want to allow empty lists and sets,
//       but that complicates type inference. We could probably do
//       what we also do with None, i.e. `List() of Integer` or `Set() of Bool`
expr_list    = { "List"     ~ "(" ~ expression ~ ("," ~ expression)* ~ ")" }
expr_set     = { "Set"      ~ "(" ~ expression ~ ("," ~ expression)* ~ ")" }