package KX_noprfkey {
    params {
        b: Bool,
        n: Integer,
        zeron: Bits(n),
        mac: fn Bits(n), Bits(n), Integer -> Bits(n),
    }

    state {
          /* H:     Table(Integer, Bool),*/          /* administrative kid, honesty */
          ctr_:  Integer,                       /* administrative sid  */
          /* kid_:  Integer, */                      /* administrative kid  */
          /* session key table, reveal -> (.,false) ; test -> (.,true) */
          RevTested:  Table((Integer,Integer,Bits(n),Bits(n),Bits(n)),
                       Bool),
          Fresh: Table(Integer, Bool),
          RevTestEval: Table((Integer,Integer,Integer,Bits(n),Bits(n)),Integer),
          ReverseMac: Table(((Integer, Integer,Integer,Bits(n),Bits(n)),(Bits(n), Integer)),Integer),
          /* Authentication */
          First:  Table((Integer,Integer,Bits(n),Bits(n),Bits(n)), Integer),
          Second: Table((Integer,Integer,Bits(n),Bits(n),Bits(n)), Integer),
          State: Table(Integer,
                  /*    administrative sid  */
                (
                 Integer,
                  /*    ID of owner of the session */
                 Bool,
                  /*    false: initiator,
                        true : responder,*/
                 Integer,
                  /* Intended Peer */
                 Integer,
                  /*    kid          */
                 Maybe(Bool),
                  /* None: running,
                        true: accepted,
                        false: rejected   */
                 Maybe(Bits(n)),
                        /* session key */
                 Maybe(Bits(n)),
                        /* initiator nonce */
                 Maybe(Bits(n)),
                        /* responder nonce */
                 Maybe(Bits(n)),
                        /* MAC key */
                 Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        /* SID */
                 Integer))
                        /* nbr of messages sent */

          }

    import oracles {
         Hon(h: Integer) -> Bool,
         Eval(h: Integer, x: (Integer, Integer, Bits(n), Bits(n), Bool)) -> Bits(n),
         Run1(state: (Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer))
         -> ((Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer),
            (Bits(n))),
         Run2(state: (Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer), ni: Bits(n))
         -> ((Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer),
            (Bits(n),Bits(n))),
         Run3(state: (Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer), msg: (Bits(n), Bits(n)))
         -> ((Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer),
            (Bits(n),Bits(n))),
         Run4(state: (Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer), msg: (Bits(n), Bits(n)))
         -> ((Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer),
            (Bits(n))),
         Run5(state: (Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer), tau: Bits(n))
         -> ((Integer,Bool,Integer,Integer,Maybe(Bool),
                        Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),Maybe(Bits(n)),
                        Maybe((Integer,Integer,Bits(n),Bits(n),Bits(n))),
                        Integer),
            (Bool)),
    }



oracle NewSession(U: Integer, u: Bool, V: Integer, kid: Integer) -> Integer {
        ctr_        <- (ctr_ + 1) ;
        State[ctr_] <- Some((U,u,V,kid,None,None,None,None,None,None,0));
        hon         <- invoke Hon(kid);
        Fresh[ctr_] <- Some(hon);
        return ctr_;
    }

oracle Send1(ctr: Integer) -> (Bits(n))
    {
        assert not (State[ctr] == None);     /* session has been initialized */
        state <- Unwrap(State[ctr]);
        return      <- invoke Run1(state);
        (state,msg) <- parse return;
        State[ctr]  <- Some(state);
        return msg;
    }

oracle Send2(ctr: Integer, msg: Bits(n)) -> (Bits(n),Bits(n))
    {
        assert not (State[ctr] == None);     /* session has been initialized */
        state   <- Unwrap(State[ctr]);
        return         <- invoke Run2(state,msg);
        (state,msg_)   <- parse return;
        State[ctr]     <-  Some(state);

        (U,u,V,kid,acc,k,ni,nr,kmac,sid,mess) <- parse state;
        ReverseMac[((kid,U,V,Unwrap(ni),Unwrap(nr)), (Unwrap(nr),2))] <- Some(ctr);

        return msg_;
    }

oracle Send3(ctr: Integer, msg: (Bits(n),Bits(n))) -> (Bits(n), Bits(n))
    {
        assert not (State[ctr] == None);    /* session has been initialized */
        state                                           <- Unwrap(State[ctr]);
        return         <- invoke Run3(state,msg);
        (state,msg_)   <- parse return;

        (U,u,V,kid,acc,k,ni,nr,kmac,sid,mess) <- parse state;
        if (mess == 2){
            if (First[Unwrap(sid)] == None) {
                First[Unwrap(sid)] <- Some(ctr);
            } else {
                if (Second[Unwrap(sid)] == None) {
                    Second[Unwrap(sid)] <- Some(ctr);
                }
            }
            ReverseMac[((kid,U,V,Unwrap(ni),Unwrap(nr)), (Unwrap(ni),3))] <- Some(ctr);
        }

        State[ctr]     <-  Some(state);
        return msg_;
    }

oracle Send4(ctr: Integer, msg: (Bits(n),Bits(n))) -> (Bits(n))
    {
        assert not (State[ctr] == None);     /* session has been initialized */
        state                                          <- Unwrap(State[ctr]);

        return       <- invoke Run4(state,msg);
        (state,msg_) <- parse return;
        State[ctr]   <- Some(state);

        (U,u,V,kid,acc,k,ni,nr,kmac,sid,mess) <- parse state;
        if (acc == Some(true)) {
            if (First[Unwrap(sid)] == None) {
                First[Unwrap(sid)] <- Some(ctr);
            } else {
              if (Second[Unwrap(sid)] == None) {
                  Second[Unwrap(sid)] <- Some(ctr);
              }
            }
            ReverseMac[((kid,U,V,Unwrap(ni),Unwrap(nr)), (zeron,4))] <- Some(ctr);
        }

        return msg_;
    }

oracle Send5(ctr: Integer, msg: Bits(n)) -> (Bool)
    {
        assert not (State[ctr] == None);    /* session has been initialized */
        state                                       <- Unwrap(State[ctr]);

        return      <- invoke Run5(state,msg);
        (state,stop) <- parse return;
        State[ctr] <- Some(state);
        return stop;
    }

oracle Reveal(ctr: Integer) -> Bits(n)
    {
    (U,u,V,kid,acc,_k,ni,nr,kmac,sid,mess) <- parse Unwrap(State[ctr]);

    /* Session accepted */
    assert (acc == Some(true));

    /* only allowed to test/reveal sid once */
    assert (RevTested[Unwrap(sid)] == None);

    /* mark key as revealed */
    RevTested[Unwrap(sid)] <- Some(false);

      RevTestEval[(kid,U,V,Unwrap(ni),Unwrap(nr))] <- Some(ctr);
      k <- invoke Eval(kid,(U,V,Unwrap(ni),Unwrap(nr),true));
    return k;
    }

oracle Test(ctr: Integer) -> Bits(n)
    {
    (U,u,V,kid,acc,_k,ni,nr,kmac,sid,mess) <- parse Unwrap(State[ctr]);

    /* Session accepted */
    assert (acc == Some(true));
    assert Unwrap(Fresh[ctr]);

    /* only allowed to test/reveal sid once */
    assert (RevTested[Unwrap(sid)] == None);

    /* mark key as tested */
    RevTested[Unwrap(sid)] <- Some(true);

    if b {
      k <-$ Bits(n);
    } else {
         RevTestEval[(kid,U,V,Unwrap(ni),Unwrap(nr))] <- Some(ctr);
         k <- invoke Eval(kid,(U,V,Unwrap(ni),Unwrap(nr) ,true));
    }
    return k;
    }

oracle SameKey(ctr1: Integer, ctr2: Integer) -> Bool {
    (_U,_u,_V,_kid,acc1,k1,_ni,_nr,_kmac,sid1,_mess) <- parse Unwrap(State[ctr1]);
    (_U,_u,_V,_kid,acc2,k2,_ni,_nr,_kmac,sid2,_mess) <- parse Unwrap(State[ctr2]);

    return false;
    }

oracle AtMost(ctr1: Integer, ctr2: Integer, ctr3: Integer) -> Bool {
    (_U,_u,_V,_kid,acc1,_k,_ni,_nr,_kmac,sid1,_mess) <- parse Unwrap(State[ctr1]);
    (_U,_u,_V,_kid,acc2,_k,_ni,_nr,_kmac,sid2,_mess) <- parse Unwrap(State[ctr2]);
    (_U,_u,_V,_kid,acc3,_k,_ni,_nr,_kmac,sid3,_mess) <- parse Unwrap(State[ctr3]);

    return false;
    }

oracle AtLeast(sid: (Integer,Integer,Bits(n),Bits(n),Bits(n))) -> Bool {

   if ((b == false) and (First[sid] != None as Integer)
                    and (Second[sid] == None)){
      (_U,_u,_V,_kid,acc1,_k,_ni,_nr,_kmac,_sid,_mess) <- parse Unwrap(State[Unwrap(First[sid])]);
      if ((acc1 == Some(true)) and (Fresh[Unwrap(First[sid])] == Some(true))) {
          return true;
      }
   }
   return false;
   }

    }